### 计算机图形学期末项目报告

#### 项目介绍及实现结果

本项目实现的是一个模仿吃豆人的走迷宫的小游戏，现阶段只实现了迷宫的构建和可操作对象的移动和视角的移动。后期会添加得分物体以实现分数获取功能。

实现结果部分截图如下：

<table>
    <tr>
        <td><img src="./pic/1.png"></td>
        <td><img src="./pic/2.png"></td>
    </tr>
    <tr>
        <td><img src="./pic/3.png"></td>
        <td><img src="./pic/4.png"></td>
    </tr>
</table>

#### 开发环境及使用到的第三方库

开发环境：VS2017

第三方库：模型载入库：assimp，贴图载入库：stb_image.h

#### 实现功能列表

**基本功能**：

1. 相机移动
2. 光照
3. 阴影实现
4. 物体贴图
5. 模型载入

**额外功能**：

1. 天空盒
2. 物体碰撞检测

#### 实现功能的简单介绍

**相机移动**：

1. camera中包含了摄像机的各种成员变量，可以通过成员函数改变相应的成员变量，当调用getViewMatrix时就返回一个最新的摄像机的view矩阵。

2. 通过回调函数监听键盘输入事件，每次监听到就改变摄像机的位置

3. 通过一个全局变量deltaTime平衡上下帧之间的时间，进而平衡摄像机的移动速度

4. 处理鼠标输入的时候，有以下步骤：

   - 计算鼠标距上一帧的偏移量。
   - 把偏移量添加到摄像机的俯仰角和偏航角中。
   - 对偏航角和俯仰角进行最大和最小值的限制。
   - 计算方向向量。

5. 处理视野缩放函数

   ```C++
   void Camera::processMouseScroll(float yoffset) {
   	if (Zoom >= 1.0f && Zoom <= 45.0f)
   		Zoom -= yoffset;
   	if (Zoom <= 1.0f)
   		Zoom = 1.0f;
   	if (Zoom >= 45.0f)
   		Zoom = 45.0f;
   }
   ```

**纹理贴图**

1. 首先调用stb_image.h库中的函数加载纹理图片。

2. 然后是生成纹理，这里我们使用一个函数将整个纹理生成的过程封装起来

   ```C++
   unsigned int loadTexture(const char* path) {
   	unsigned int textureID;
   	glGenTextures(1, &textureID);
   
   	int width, height, nrComponents;
   	unsigned char *data = stbi_load(path, &width, &height, &nrComponents, 0);
   	if (data)
   	{
   		GLenum format;
   		if (nrComponents == 1)
   			format = GL_RED;
   		else if (nrComponents == 3)
   			format = GL_RGB;
   		else if (nrComponents == 4)
   			format = GL_RGBA;
   
   		glBindTexture(GL_TEXTURE_2D, textureID);
   		glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);
   		glGenerateMipmap(GL_TEXTURE_2D);
   
   		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
   		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
   		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
   		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
   
   		stbi_image_free(data);
   	}
   	else
   	{
   		std::cout << "Texture failed to load at path: " << path << std::endl;
   		stbi_image_free(data);
   	}
   
   	return textureID;
   }
   ```

3. 应用纹理的时候需要在顶点数组中添加纹理坐标，然后在顶点着色器中调整顶点着色器使其能够接受顶点坐标为一个顶点属性，并把坐标传给片段着色器。

4. 然后因为我们的纹理贴图结合了光照，因此在片段着色器中，通过纹理坐标，从纹理中采样片段的漫反射，镜面反射的颜色值，将得到的光贴图FragColor渲染到物体上。

5. 在调用glDrawElements之前绑定纹理了，它会自动把纹理赋值给片段着色器的采样器：

   ```C++
   glActiveTexture(GL_TEXTURE0);
   glBindTexture(GL_TEXTURE_2D, containerMap);
   ```

纹理贴图的效果：

![7](D:\HW\CG\CG_Final\CG_2019_Final\final_work_V0\doc\pic\7.PNG)

**光照**

采用的是冯氏光照模型，由于地面是没有纹理的，而物体和迷宫的墙壁是有纹理的，因此我设置了一个参数可以选择纹理或者颜色。这样就可以实现光照贴图是时候既能展示没有纹理的地板，也可以展示有纹理的物体。

```C++
vec3 color = texture(diffuseTexture, fs_in.TexCoords).rgb;
vec3 objColor = (typeColor) ? objectColor : color;
```

**阴影部分**

使用之前作业实现阴影的方法，直接就拿过来用了，简单来说，实现阴影有两个步骤：

1. 首先，需要渲染深度贴图
2. 使用生成的深度贴图计算片元是否在阴影中，以摄像机方向。

光照和阴影的效果：

![5](D:\HW\CG\CG_Final\CG_2019_Final\final_work_V0\doc\pic\5.PNG)

**模型的载入**

使用的是assimp库，首先我们需要新建一个model类，其中有构造器，在构造器中，它会直接通过loadModel来加载文件。在这个函数中我们使用Assimp来加载模型至Assimp的一个叫做scene的数据结构中。然后将Assimp的数据结构解析到Mesh对象中，这也是一个类，处理网格的过程主要有三部分：获取所有的顶点数据，获取它们的网格索引，并获取相关的材质数据。处理后的数据将会储存在三个vector当中，我们会利用它们构建一个Mesh对象，并返回它到函数的调用者那里。

效果：

![6](D:\HW\CG\CG_Final\CG_2019_Final\final_work_V0\doc\pic\6.PNG)

**物体碰撞检测**

这里使用的是最简单的碰撞检测，通过存储每一个组成墙壁的正方体的坐标，然后物体的大小设计成和正方体的大小一致，物体每次移动一个正方体的长度，也就是说，物体每一次移动一格，然后通过map判断这一格是否存在墙壁正方体，如果存在，将物体的位置回退一格。

```C++
rightTo -= 15.0f*deltaTime;
glm::vec3 position = glm::vec3(roundf(forwardTo), 0.0f, roundf(rightTo));
if (!canMove(position)) {
    rightTo += 15.0f*deltaTime;
}
//canMove
std::map<int, glm::vec3>::iterator iter;
for (iter = wall.begin(); iter != wall.end(); iter++) {
    if (iter->second == nextPosition) return false;
}
return true;
```

#### 遇到的问题和解决方法

我在实现碰撞检测的时候一开始使用的是测量碰撞物体和墙壁之间的距离，当距离小于一定的值后判断为碰撞，但是比较难实现，因为需要判断是哪一面发生了碰撞，比较繁琐，因此我选择让物体每次移动一个单元，然后判断这个单元是否为墙壁，移动一个单元的实现方法是通过deltaTime控制移动距离，然后通过round函数保证移动的距离为整数，这个15.0f保证了每一移动的距离是一个大于0.5小于1的值：

```C++
rightTo -= 15.0f*deltaTime;
glm::vec3 position = glm::vec3(roundf(forwardTo), 0.0f, roundf(rightTo));
if (!canMove(position)) {
    rightTo += 15.0f*deltaTime;
}
```

#### 小组成员分工

王亮岛：负责光照和阴影的实现，摄像机移动的实现，以及纹理贴图的实现，拓展功能实现了碰撞检测。